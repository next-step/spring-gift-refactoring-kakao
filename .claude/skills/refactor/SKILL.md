---
name: refactor
description: 코드 리팩터링을 수행하고 docs/ 하위에 변경 사유와 대안 비교를 포함한 보고서를 작성하는 스킬.
---

# Refactor Skill

코드 리팩터링을 수행하고, 변경 사유와 대안 비교 분석을 포함한 보고서를 `docs/` 디렉터리에 작성하는 스킬이다.

## 핵심 원칙

1. **보고서 선행 작성** — 코드를 변경하기 전에 보고서를 먼저 작성한다. 보고서 없이 코드를 수정하지 않는다.
2. **변경 사유 필수** — 모든 변경에는 "왜 이렇게 변경하는가"에 대한 명확한 답이 있어야 한다.
3. **대안 비교 필수** — 선택한 방법 외에 다른 대안들을 제시하고, 각각의 장단점을 비교 분석한다.
4. **작동 보존** — 리팩터링은 외부에서 관찰 가능한 동작을 변경하지 않는다.
5. **하나의 작업 단위** — 사용자가 요청하면 반드시 하나의 작업만 수행한다.

---

## 보고서 작성 규칙

### 파일 위치 및 명명

```
docs/[리팩터링주제]-리팩터링.md
```

예시:
- `docs/서비스-계층-추출-리팩터링.md`
- `docs/스타일-정리-리팩터링.md`
- `docs/미사용-코드-제거-리팩터링.md`

### 보고서 구조

모든 리팩터링 보고서는 다음 구조를 따른다:

```markdown
# [리팩터링 주제] 리팩터링 보고서

> 대상 범위: [변경 대상 요약]

## 1. 왜 이렇게 변경하는가

### 1-1. 현재 문제

현재 코드의 구체적인 문제점을 서술한다.
- 문제의 근거가 되는 코드 위치 (파일경로:라인번호)
- 이 문제가 유지보수/확장/가독성에 미치는 영향

### 1-2. 변경 목표

리팩터링 후 달성하려는 상태를 명확히 기술한다.

### 1-3. 변경 사유 요약

한 문장으로 "왜"를 요약한다.
예: "Controller에 비즈니스 로직이 섞여 있어 테스트와 변경이 어렵다. 책임 분리를 통해 변경 용이성을 확보한다."

## 2. 대안 비교 분석

### 대안 A: [방법명]

- **설명**: 구체적인 접근 방식
- **장점**:
- **단점**:

### 대안 B: [방법명]

- **설명**: 구체적인 접근 방식
- **장점**:
- **단점**:

### (필요시 대안 C, D...)

### 비교 요약

| 기준 | 대안 A | 대안 B | ... |
|------|--------|--------|-----|
| 변경 범위 | | | |
| 안전성 | | | |
| 일관성 | | | |
| 복잡도 | | | |

### 선택 및 근거

선택한 대안과 그 이유를 명시한다.

## 3. 변경 계획

### 3-N. [변경 항목]

각 변경 항목에 대해:
- **대상 파일**: 변경할 파일 경로
- **변경 내용**: 구체적으로 무엇을 어떻게 변경하는지
- **변경 사유**: 이 개별 변경이 필요한 이유

## 4. 검증 방법

리팩터링 후 작동이 보존되었음을 확인하는 방법을 기술한다.
- 실행할 테스트
- 확인할 항목
```

---

## 작업 절차

### 1단계: 현황 분석

리팩터링 대상의 현재 상태를 파악한다.

```
1. 대상 파일/패키지 읽기
2. 의존성, 책임, 구조 파악
3. 문제점 식별 및 근거 수집
```

### 2단계: 대안 도출 및 비교

가능한 리팩터링 접근 방식을 도출하고 비교한다.

```
1. 최소 2개 이상의 대안 도출
2. 각 대안의 장단점 분석
3. 프로젝트 컨텍스트에 맞는 최적 대안 선택
4. 선택 근거 정리
```

### 3단계: 보고서 작성

`docs/` 하위에 리팩터링 보고서를 작성한다.

```
1. 보고서 템플릿에 맞춰 내용 구성
2. docs/[리팩터링주제]-리팩터링.md 파일 생성
3. 사용자에게 보고서 리뷰 요청
```

### 4단계: 코드 변경

보고서의 변경 계획에 따라 코드를 수정한다.

```
1. 변경 계획의 각 항목을 순서대로 수행
2. 항목별 변경 후 컴파일 확인
3. 전체 변경 완료 후 테스트 실행
```

### 5단계: 스타일 적용

Java 코드를 변경한 경우, 반드시 Spotless 포매터를 실행한다.

```
1. ./gradlew spotlessApply — 자동 포매팅 적용
2. ./gradlew spotlessCheck — 포매팅 위반 없음 확인
```

### 6단계: 검증

리팩터링 후 작동이 보존되었는지 확인한다.

```
1. 전체 테스트 실행 → 통과 확인
2. 보고서의 검증 항목 확인
3. 실패 시 원인 분석 후 수정
```

---

## 커밋 메시지 규칙

**커밋을 직접 수행하지 않는다.** 코드 변경 완료 후 커밋 메시지를 작성하여 사용자에게 전달한다. 사용자가 직접 커밋한다.

### 형식: AngularJS Git Commit Message Conventions

커밋 메시지는 한국어로 작성하되, type은 영어로 작성한다.

```
<type>(<scope>): <subject>

<body>

<footer>
```

- **type** (영어): `refactor`, `fix`, `feat`, `style`, `docs`, `test`, `chore` 등
- **scope** (선택): 변경 대상 모듈/패키지
- **subject** (한국어): 변경 요약 (명령형)
- **body** (한국어): 변경 사유 — "왜 이렇게 변경하는가"와 선택한 접근 방식의 근거
- **footer** (선택): 관련 이슈 번호 등

### 필수 포함 내용

- 작업 목록 단위로 커밋 메시지를 작성한다
- 변경 이유가 body에 정확하게 포함되어야 한다

### 예시

```
refactor(product): ProductController 비즈니스 로직을 ProductService로 추출

Controller에 CRUD 로직이 직접 포함되어 있어 테스트 작성과 로직 변경이
어렵다. 도메인 단위로 Service를 추출하여 Controller는 요청 검증과
위임만 담당하도록 책임을 분리한다.

대안으로 메서드 단위 추출을 검토했으나, 도메인 단위 추출이 응집도와
일관성 측면에서 더 적합하다고 판단했다.
```

---

## 주의사항

### 절대 하지 말 것
- 보고서 없이 코드 수정
- 외부 동작 변경 (API 응답, 비즈니스 규칙 등)
- 한 번에 여러 작업 단위를 수행
- 대안 비교 없이 단일 방법만 제시
- **직접 git commit 수행** (커밋은 사용자가 한다)

### 반드시 할 것
- 코드 변경 전에 보고서 작성
- 모든 변경에 "왜"를 명시
- 최소 2개 이상의 대안을 비교 분석
- 각 변경 항목에 파일 경로와 변경 사유 기록
- 변경 후 전체 테스트 실행으로 작동 보존 확인
- 작업 목록 단위로 커밋 메시지 작성, 변경 사유 포함
- **커밋 메시지를 사용자에게 전달** (AngularJS Convention, 한국어, type은 영어)
