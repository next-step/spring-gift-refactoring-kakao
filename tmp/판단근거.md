# 판단근거

## 1. 스타일 정리 판단근거

### 1-1. @author/@since Javadoc 제거
- **현황**: 8개 파일(auth, member 패키지)에만 `@author brian.kim` / `@since 1.0` 존재. 나머지 22개+ 파일에는 없음
- **판단**: 프로젝트 다수파(Javadoc 없음)에 맞춰 제거. git 이력으로 저자 추적 가능하므로 코드 내 @author 불필요
- **작동 영향**: 없음 (주석만 변경)

### 1-2. @Autowired 제거
- **현황**: 4개 파일(AuthenticationResolver, JwtProvider, AdminMemberController, MemberController)에만 `@Autowired` 사용. 나머지 컨트롤러/컴포넌트는 생성자 주입만으로 동작
- **판단**: Spring 4.3+ 이후 생성자가 1개면 `@Autowired` 생략 가능. 프로젝트 대다수가 생략 → "없는 쪽"으로 통일
- **작동 영향**: 없음 (Spring 동작 동일)

### 1-3. Entity 필드 빈 줄 통일
- **현황**: `Member.java`만 필드 사이에 빈 줄 존재. `Product`, `Option`, `Order`, `Category`, `Wish` 엔티티는 빈 줄 없음
- **판단**: 다수파(빈 줄 없음)에 맞춰 `Member.java`의 필드 빈 줄 제거
- **작동 영향**: 없음 (공백만 변경)

### 1-4. Collectors.toList() → .toList()
- **현황**: `OptionController.java:43`에서만 `.collect(Collectors.toList())` 사용. `CategoryController.java:30`에서는 `.toList()` 사용
- **판단**: Java 16+ `.toList()`로 통일. 프로젝트는 Java 21 사용
- **차이점 인지**: `.toList()`는 불변 리스트 반환, `Collectors.toList()`는 가변 리스트 반환. `OptionController`에서 반환된 리스트를 수정하는 코드가 없으므로 작동 변경 없음
- **작동 영향**: 없음 (반환값이 수정되지 않으므로 불변/가변 차이가 영향 없음)

---

## 2. 불필요한 코드 제거 판단근거

### 2-1. OrderController.wishRepository (미사용 필드)
- **미사용 확인**: `grep -rn "wishRepository" OrderController.java` 결과, 선언(line 26), 생성자 파라미터(line 34), 할당(line 41)만 존재. 메서드 내에서 `wishRepository`를 호출하는 코드 **0건**
- **주변 주석/TODO 확인**: line 67에 `// 6. cleanup wish` 주석 존재 → 주문 시 위시 정리 기능을 **의도했으나 미구현** 상태
- **git blame 확인**: `55ca9e43 (wotjd243 2026-02-18)` — 초기 프로젝트 세팅 커밋에서 추가됨. 별도 커밋 메시지에 wish cleanup 관련 언급 없음
- **이후 단계 충돌 가능성**: 서비스 계층 추출 시 OrderService로 이동하게 되면 어차피 Service에서 주입 여부를 재결정하게 됨. 현재 미사용 상태이므로 제거 후, 이후 "cleanup wish" 기능이 구현되는 시점에 다시 추가하는 것이 깔끔
- **판단**: **제거한다.** 주석 `// 6. cleanup wish`는 유지하여 미구현 사실을 표시하되, 미사용 필드/import/생성자 파라미터는 제거

### 2-2. OptionController의 Collectors import
- **미사용 확인**: 단계 1-4에서 `.collect(Collectors.toList())`를 `.toList()`로 변환하면 `Collectors`를 사용하는 곳이 0건이 됨
- **판단**: 단계 1-4 적용 후 해당 import 제거

---

## 3. 서비스 계층 추출 판단근거

### 3-1. OrderController → OrderService 추출
- **Controller에 있는 비즈니스 로직**:
  - 옵션 존재 여부 검증 (line 81-84)
  - 옵션 재고 차감: `option.subtractQuantity()` + `optionRepository.save()` (line 87-88)
  - 포인트 계산 및 차감: `member.deductPoint()` + `memberRepository.save()` (line 91-93)
  - 주문 생성: `orderRepository.save(new Order(...))` (line 96)
  - 카카오 알림 전송: `sendKakaoMessageIfPossible()` (line 99, 104-113)
- **"왜 비즈니스 로직인가"**: 재고 차감, 포인트 차감, 주문 저장은 하나의 트랜잭션으로 묶여야 하는 핵심 도메인 로직. HTTP 요청/응답 변환과는 무관
- **추출 후 Controller 역할**: 인증 확인 → `OrderService.createOrder()` 호출 → HTTP 응답 변환
- **작동 동일성 보장**: 기존 테스트(`OrderControllerTest`) 전체 통과 + Service 단위 테스트 추가

### 3-2. MemberController → MemberService 추출
- **Controller에 있는 비즈니스 로직**:
  - 이메일 중복 검사: `memberRepository.existsByEmail()` (line 35)
  - 회원 생성 + 저장: `memberRepository.save(new Member(...))` (line 39)
  - 비밀번호 검증: `member.getPassword().equals(request.password())` (line 49)
  - JWT 토큰 생성: `jwtProvider.createToken()` (line 40, 53)
- **"왜 비즈니스 로직인가"**: 회원 가입 규칙(중복 불가)과 인증 로직(비밀번호 비교 + 토큰 발급)은 HTTP 계층과 무관한 도메인 규칙

### 3-3. KakaoAuthController → KakaoAuthService 추출
- **Controller에 있는 비즈니스 로직**:
  - OAuth URL 생성 (line 42-48)
  - 토큰 교환 + 사용자 정보 조회 (line 57-58)
  - 회원 조회 또는 자동 등록 (line 61-62)
  - 카카오 액세스 토큰 갱신 (line 63)
  - 회원 저장 + JWT 발급 (line 64, 66)
- **"왜 비즈니스 로직인가"**: 외부 API 호출, 회원 자동 등록, 토큰 관리는 도메인 로직

### 3-4. OptionController → OptionService 추출
- **Controller에 있는 비즈니스 로직**:
  - 옵션명 검증: `OptionNameValidator.validate()` (line 52, 93-98)
  - 중복 옵션명 검사: `optionRepository.existsByProductIdAndName()` (line 59)
  - 최소 옵션 수 제약: `options.size() <= 1` 이면 삭제 불가 (line 79-82)
- **"왜 비즈니스 로직인가"**: "상품에는 항상 1개 이상의 옵션이 있어야 한다"는 도메인 불변 규칙

### 3-5. WishController → WishService 추출
- **Controller에 있는 비즈니스 로직**:
  - 상품 존재 확인 (line 63-66)
  - 중복 위시 확인: `wishRepository.findByMemberIdAndProductId()` (line 69-72)
  - 소유자 확인: `wish.getMemberId().equals(member.getId())` (line 95-97)
- **"왜 비즈니스 로직인가"**: 중복 위시 방지, 소유자 권한 확인은 도메인 규칙

### 3-6. ProductController / AdminProductController → ProductService 추출
- **Controller에 있는 비즈니스 로직**:
  - 상품명 검증: `ProductNameValidator.validate()` (ProductController line 50, 67 / AdminProductController line 47, 80)
  - 카테고리 존재 확인 (ProductController line 52-55, 69-72 / AdminProductController line 53-54, 86-87)
- **"왜 비즈니스 로직인가"**: 상품명 규칙 검증과 카테고리 연관 검증은 도메인 규칙. 두 컨트롤러에서 중복됨

### 3-7. AdminMemberController → MemberService 연결
- **Controller에 있는 비즈니스 로직**:
  - 이메일 중복 검사 (line 45) — MemberController.register()와 동일 로직
  - 포인트 충전 (line 82)
- **"왜 비즈니스 로직인가"**: 이메일 중복 검사는 MemberController와 중복. MemberService에 이미 추출할 예정이므로 재사용

### 3-8. CategoryController → CategoryService 추출
- **Controller에 있는 비즈니스 로직**: 거의 없음 (단순 CRUD)
- **추출 이유**: 프로젝트 전체의 Controller-Service 패턴 일관성 확보

---

## 4. 서비스 추출 실행 기록

### 4-1. OrderController → OrderService 추출 (완료)
- **Service로 이동한 로직**:
  - `getOrders()`: 주문 목록 조회 (Repository 호출 + DTO 변환)
  - `createOrder()`: 옵션 검증, 재고 차감, 포인트 차감, 주문 저장, 카카오 알림
  - `sendKakaoMessageIfPossible()`: best-effort 카카오 메시지 전송
- **Controller에 남긴 역할**: 인증 확인(`authenticationResolver.extractMember`) + Service 위임 + HTTP 응답 변환
- **예외 처리 변경**: 옵션 미존재 시 Controller가 `orElse(null)` → Service가 `orElseThrow(NoSuchElementException)` 후 Controller에서 catch → 404 응답. 외부 동작(HTTP 응답 코드)은 동일
- **작동 동일성 검증**: 기존 테스트 7개 → Service 모킹 방식으로 전환 후 7개 전체 통과 (카카오 메시지 전송/미전송 테스트는 Service 내부 동작이므로 Controller 테스트에서 제거, Service 단위 테스트에서 검증 예정)
